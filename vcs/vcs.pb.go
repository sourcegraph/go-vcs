// Code generated by protoc-gen-gogo.
// source: vcs.proto
// DO NOT EDIT!

/*
Package vcs is a generated protocol buffer package.

It is generated from these files:
	vcs.proto

It has these top-level messages:
	Commit
	Signature
	Branch
	BehindAhead
	BranchesOptions
	Tag
	SearchOptions
	SearchResult
	Committer
*/
package vcs

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto"
import pbtypes "sourcegraph.com/sqs/pbtypes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Commit struct {
	ID        CommitID   `protobuf:"bytes,1,opt,name=ID,proto3,customtype=CommitID" json:"ID,omitempty"`
	Author    Signature  `protobuf:"bytes,2,opt,name=Author" json:"Author"`
	Committer *Signature `protobuf:"bytes,3,opt,name=Committer" json:"Committer,omitempty"`
	Message   string     `protobuf:"bytes,4,opt,name=Message,proto3" json:"Message,omitempty"`
	// Parents are the commit IDs of this commit's parent commits.
	Parents []CommitID `protobuf:"bytes,5,rep,name=Parents,customtype=CommitID" json:"Parents,omitempty"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}

func (m *Commit) GetAuthor() Signature {
	if m != nil {
		return m.Author
	}
	return Signature{}
}

func (m *Commit) GetCommitter() *Signature {
	if m != nil {
		return m.Committer
	}
	return nil
}

type Signature struct {
	Name  string            `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Email string            `protobuf:"bytes,2,opt,name=Email,proto3" json:"Email,omitempty"`
	Date  pbtypes.Timestamp `protobuf:"bytes,3,opt,name=Date" json:"Date"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}

func (m *Signature) GetDate() pbtypes.Timestamp {
	if m != nil {
		return m.Date
	}
	return pbtypes.Timestamp{}
}

// A Branch is a VCS branch.
type Branch struct {
	// Name is the name of this branch.
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	// Head is the commit ID of this branch's head commit.
	Head CommitID `protobuf:"bytes,2,opt,name=Head,proto3,customtype=CommitID" json:"Head,omitempty"`
	// Commit optionally contains commit information for this branch's head commit.
	// It is populated if IncludeCommit option is set.
	Commit *Commit `protobuf:"bytes,4,opt,name=Commit" json:"Commit,omitempty"`
	// Counts optionally contains the commit counts relative to specified branch.
	Counts *BehindAhead `protobuf:"bytes,3,opt,name=Counts" json:"Counts,omitempty"`
}

func (m *Branch) Reset()         { *m = Branch{} }
func (m *Branch) String() string { return proto.CompactTextString(m) }
func (*Branch) ProtoMessage()    {}

func (m *Branch) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *Branch) GetCounts() *BehindAhead {
	if m != nil {
		return m.Counts
	}
	return nil
}

// BehindAhead is a set of behind/ahead counts.
type BehindAhead struct {
	Behind uint32 `protobuf:"varint,1,opt,name=Behind,proto3" json:"Behind,omitempty"`
	Ahead  uint32 `protobuf:"varint,2,opt,name=Ahead,proto3" json:"Ahead,omitempty"`
}

func (m *BehindAhead) Reset()         { *m = BehindAhead{} }
func (m *BehindAhead) String() string { return proto.CompactTextString(m) }
func (*BehindAhead) ProtoMessage()    {}

// BranchesOptions specifies options for the list of branches returned by
// (Repository).Branches.
type BranchesOptions struct {
	// MergedInto will cause the returned list to be restricted to only
	// branches that were merged into this branch name.
	MergedInto string `protobuf:"bytes,4,opt,name=MergedInto,proto3" json:"MergedInto,omitempty" url:",omitempty"`
	// IncludeCommit controls whether complete commit information is included.
	IncludeCommit bool `protobuf:"varint,2,opt,name=IncludeCommit,proto3" json:"IncludeCommit,omitempty" url:",omitempty"`
	// BehindAheadBranch specifies a branch name. If set to something other than blank
	// string, then each returned branch will include a behind/ahead commit counts
	// information against the specified base branch. If left blank, then branches will
	// not include that information and their Counts will be nil.
	BehindAheadBranch string `protobuf:"bytes,1,opt,name=BehindAheadBranch,proto3" json:"BehindAheadBranch,omitempty" url:",omitempty"`
	// ContainsCommit filters the list of branches to only those that
	// contain a specific commit ID (if set).
	ContainsCommit string `protobuf:"bytes,3,opt,name=ContainsCommit,proto3" json:"ContainsCommit,omitempty" url:",omitempty"`
}

func (m *BranchesOptions) Reset()         { *m = BranchesOptions{} }
func (m *BranchesOptions) String() string { return proto.CompactTextString(m) }
func (*BranchesOptions) ProtoMessage()    {}

// A Tag is a VCS tag.
type Tag struct {
	Name     string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	CommitID CommitID `protobuf:"bytes,2,opt,name=CommitID,proto3,customtype=CommitID" json:"CommitID,omitempty"`
}

func (m *Tag) Reset()         { *m = Tag{} }
func (m *Tag) String() string { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()    {}

// SearchOptions specifies options for a repository search.
type SearchOptions struct {
	// the query string
	Query string `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	// currently only FixedQuery ("fixed") is supported
	QueryType string `protobuf:"bytes,2,opt,name=QueryType,proto3" json:"QueryType,omitempty"`
	// the number of lines before and after each hit to display
	ContextLines int32 `protobuf:"varint,3,opt,name=ContextLines,proto3" json:"ContextLines,omitempty"`
	// max number of matches to return
	N int32 `protobuf:"varint,4,opt,name=N,proto3" json:"N,omitempty"`
	// starting offset for matches (use with N for pagination)
	Offset int32 `protobuf:"varint,5,opt,name=Offset,proto3" json:"Offset,omitempty"`
}

func (m *SearchOptions) Reset()         { *m = SearchOptions{} }
func (m *SearchOptions) String() string { return proto.CompactTextString(m) }
func (*SearchOptions) ProtoMessage()    {}

// A SearchResult is a match returned by a search.
type SearchResult struct {
	// File is the file that contains this match.
	File string `protobuf:"bytes,1,opt,name=File,proto3" json:"File,omitempty"`
	// The byte range [start,end) of the match.
	StartByte uint32 `protobuf:"varint,2,opt,name=StartByte,proto3" json:"StartByte,omitempty"`
	EndByte   uint32 `protobuf:"varint,3,opt,name=EndByte,proto3" json:"EndByte,omitempty"`
	// The line range [start,end] of the match.
	StartLine uint32 `protobuf:"varint,4,opt,name=StartLine,proto3" json:"StartLine,omitempty"`
	EndLine   uint32 `protobuf:"varint,5,opt,name=EndLine,proto3" json:"EndLine,omitempty"`
	// Match is the matching portion of the file from [StartByte,
	// EndByte).
	Match []byte `protobuf:"bytes,6,opt,name=Match,proto3" json:"Match,omitempty"`
}

func (m *SearchResult) Reset()         { *m = SearchResult{} }
func (m *SearchResult) String() string { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()    {}

// A Committer is a contributor to a repository.
type Committer struct {
	Name    string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Email   string `protobuf:"bytes,2,opt,name=Email,proto3" json:"Email,omitempty"`
	Commits int32  `protobuf:"varint,3,opt,name=Commits,proto3" json:"Commits,omitempty"`
}

func (m *Committer) Reset()         { *m = Committer{} }
func (m *Committer) String() string { return proto.CompactTextString(m) }
func (*Committer) ProtoMessage()    {}
